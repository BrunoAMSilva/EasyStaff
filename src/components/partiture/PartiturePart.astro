---
import type { Part, Note, Measure } from "../../content.config";
import PartitureBeats from "./PartitureBeats.astro";
import PartitureMeasure from "./PartitureMeasure.astro";
import PartitureStaff from "./PartitureStaff.astro";
import PartitureSlursTies from "./PartitureSlursTies.astro";
import { prepareNotesForAudio } from "../../utils/audio-helpers";
import { extractTempo } from "../../utils/tempo";

interface Props {
    partiturePart: Part;
}

const { partiturePart } = Astro.props;
const firstMeasure = partiturePart.measures[0];
const staves = firstMeasure.attributes?.staves || 1;

// Calculate tie information for all notes
// This will help us extend first note duration and hide continuation notes
interface TieInfo {
    isStart: boolean;
    isMiddle: boolean;
    isEnd: boolean;
    totalDuration: number; // Only set for start notes
}

const tieInfoMap = new Map<string, TieInfo>(); // key: `measureIndex-noteIndex`

// Build a flat list of all notes with their positions
interface NoteRef {
    measureIndex: number;
    noteIndexInMeasure: number;
    note: Note;
    staff: number;
    pitch: string; // staff-pitch-octave
}

const allNotes: NoteRef[] = [];
partiturePart.measures.forEach((measure, measureIndex) => {
    measure.notes.forEach((note, noteIndex) => {
        if (note.pitch) {
            const staff = note.staff || 1;
            const pitch = `${staff}-${note.pitch.step}${note.pitch.octave}`;
            allNotes.push({
                measureIndex,
                noteIndexInMeasure: noteIndex,
                note,
                staff,
                pitch
            });
        }
    });
});

// Track active ties and calculate durations
const activeTies = new Map<string, { startIndex: number; duration: number }>();

allNotes.forEach((noteRef, index) => {
    const { note, pitch, measureIndex, noteIndexInMeasure } = noteRef;
    const key = `${measureIndex}-${noteIndexInMeasure}`;
    
    const hasTieStart = note.tie?.type === 'start' || note.notations?.tied?.type === 'start';
    const hasTieStop = note.tie?.type === 'stop' || note.notations?.tied?.type === 'stop';
    
    if (hasTieStart) {
        // This is the start of a tie
        activeTies.set(pitch, { startIndex: index, duration: note.duration || 1 });
        tieInfoMap.set(key, {
            isStart: true,
            isMiddle: false,
            isEnd: false,
            totalDuration: note.duration || 1
        });
    } else if (hasTieStop) {
        // This is the end (or middle) of a tie
        const activeTie = activeTies.get(pitch);
        if (activeTie) {
            activeTie.duration += (note.duration || 1);
            
            // Update the start note with total duration
            const startNote = allNotes[activeTie.startIndex];
            const startKey = `${startNote.measureIndex}-${startNote.noteIndexInMeasure}`;
            const startInfo = tieInfoMap.get(startKey);
            if (startInfo) {
                startInfo.totalDuration = activeTie.duration;
            }
            
            // Mark this as end or middle
            const isEnd = !(note.tie?.type === 'start' || note.notations?.tied?.type === 'start');
            tieInfoMap.set(key, {
                isStart: false,
                isMiddle: !isEnd,
                isEnd: isEnd,
                totalDuration: 0
            });
            
            if (isEnd) {
                activeTies.delete(pitch);
            }
        }
    }
});

// Make tie info available to measures via a global
// (Astro doesn't have React-style context, so we use this approach)
(globalThis as any).__tieInfoMap = tieInfoMap;
const stavesGrids: Record<number, string> = {
    1: "grid-rows-13",
    2: "grid-rows-26",
    3: "grid-rows-39",
};
let currentMeasureAttributes = firstMeasure.attributes;
let currentMeasureDirections = firstMeasure.directions;
const mappedMeasures = partiturePart.measures.map((measure) => {
    measure.attributes = measure.attributes
        ? { ...currentMeasureAttributes, ...measure.attributes }
        : currentMeasureAttributes;
    measure.directions = measure.directions
        ? measure.directions
        : currentMeasureDirections;
    currentMeasureAttributes = measure.attributes;
    currentMeasureDirections = measure.directions;
    return measure;
});

const totalMeasures = mappedMeasures.length;
const totalBeats = currentMeasureAttributes?.time.beats
    ? mappedMeasures.reduce((sum, measure) => {
          return sum + (measure.attributes?.time.beats || 0);
      }, 0)
    : mappedMeasures.length;
const tempo = extractTempo(currentMeasureDirections);
const divisions = currentMeasureAttributes?.divisions || 1;
// Prepare note data for audio playback using utility function
const notesForAudio = prepareNotesForAudio(partiturePart);
---

<div
    class={`grid staff-host overflow-x-auto relative`}
    
>
    <div
        style={`grid-template-columns: 18em repeat(${totalMeasures}, 120px 120px 120px 120px);`}
        class={`staff-grid p-10 row-span-full grid ${stavesGrids[staves]}`}
    >
        <PartitureBeats
            tempo={tempo}
            beats={totalBeats}
            beatsPerMeasure={currentMeasureAttributes?.time.beats || 4}
            offsetStart={1}
        />
        {
            Array.from({ length: staves }).map((_, idx) => (
                <PartitureStaff
                    staffNumber={idx + 1}
                    clef={idx === 0 ? "treble" : "bass"}
                />
            ))
        }
        {
            mappedMeasures.map((measure, index) => {
                return <PartitureMeasure measure={measure} offsetStart={1} measureIndex={index} />;
            })
        }
        <PartitureSlursTies partiturePart={partiturePart} />
    </div>
    <div class="playhead"></div>
</div>
<style is:global>

    .staff-grid {
        margin-inline-start: calc(50vw - (var(--spacing) * 16) - 16em);
        margin-inline-end: 48vw;
        font-size: clamp(0.75rem, 2vmin, 2rem);
    }

    .playhead {
        position: sticky;
        top: 0;
        bottom: 0;
        grid-column: 1 / -1;
        position: sticky;
        left: 50vw;
        grid-row: 1 / -1;
        width: 2px;
        background: rgba(59, 130, 246, 0.9);
        pointer-events: none;
        z-index: 50;
    }
</style>
<script is:inline define:vars={{ tempo, totalBeats, notesForAudio, divisions }}>
    // Store partiture data in window scope for audio integration
    // Use a unique key per component to avoid conflicts with multiple partitures
    window.__partitureData = window.__partitureData || {};
    window.__partitureData.tempo = tempo;
    window.__partitureData.totalBeats = totalBeats;
    window.__partitureData.notesForAudio = notesForAudio;
    window.__partitureData.divisions = divisions;
</script>
<script>
    import { PartiturePlayer } from "../../utils/partiture-player";
    
    const tempo = window.__partitureData?.tempo || 120;
    const totalBeats = window.__partitureData?.totalBeats || 0;
    const notesForAudio = window.__partitureData?.notesForAudio || [];
    const divisions = window.__partitureData?.divisions || 1;
    
    const player = new PartiturePlayer({
        defaultTempo: Number(tempo) || 120,
        totalBeatsHint: Number(totalBeats) || 0,
    });
    
    player.setAudioData(notesForAudio, divisions);
    player.setupEventListeners();
    player.rebuildHosts();
    
</script>

