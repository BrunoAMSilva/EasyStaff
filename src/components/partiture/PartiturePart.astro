---
import type { Part } from "../../content.config";
import PartitureBeats from "./PartitureBeats.astro";
import PartitureMeasure from "./PartitureMeasure.astro";
import PartitureStaff from "./PartitureStaff.astro";

interface Props {
    partiturePart: Part;
}
const { partiturePart } = Astro.props;
const firstMeasure = partiturePart.measures[0];
const staves = firstMeasure.attributes?.staves || 1;
const stavesGrids: Record<number, string> = {
    1: "grid-rows-13",
    2: "grid-rows-26",
    3: "grid-rows-39",
};
let currentMeasureAttributes = firstMeasure.attributes;
let currentMeasureDirections = firstMeasure.directions;
const mappedMeasures = partiturePart.measures.map((measure) => {
    measure.attributes = measure.attributes
        ? { ...currentMeasureAttributes, ...measure.attributes }
        : currentMeasureAttributes;
    measure.directions = measure.directions
        ? measure.directions
        : currentMeasureDirections;
    currentMeasureAttributes = measure.attributes;
    currentMeasureDirections = measure.directions;
    return measure;
});

const totalMeasures = mappedMeasures.length;
const totalBeats = currentMeasureAttributes?.time.beats
    ? mappedMeasures.reduce((sum, measure) => {
          return sum + (measure.attributes?.time.beats || 0);
      }, 0)
    : mappedMeasures.length;
const beatsPerMeasure = firstMeasure.directions?.directionType.perMinute || 4;
const tempo = firstMeasure.directions?.sound?.tempo || 120;
const divisions = currentMeasureAttributes?.divisions || 1;

// Prepare note data for audio playback
const notesForAudio = mappedMeasures.flatMap((measure, measureIndex) => {
    const beats = measure.attributes?.time.beats || 4;
    const measureNumber = measure.number ? parseInt(measure.number) : measureIndex + 1;
    const totalBeatsBefore = (measureNumber - 1) * beats + 1;
    
    const currentBeats = new Map<number, number>(
        new Array(staves).fill(0).map((_, idx) => [idx + 1, 0])
    );
    const lastNotes = new Map();
    
    return measure.notes.map((note) => {
        const staff = note.staff || 1;
        const beat = currentBeats.get(staff) || 0;
        
        const lastNote = lastNotes.get(staff);
        lastNotes.set(staff, note);
        
        let currentBeat;
        if (!lastNote || note.isChord) {
            currentBeat = beat === 0 ? 1 : beat;
            currentBeats.set(staff, currentBeat);
        } else {
            currentBeat = beat === 0 ? 1 : beat + (lastNote.duration || 1);
            currentBeats.set(staff, currentBeat);
        }
        
        return {
            note: {
                pitch: note.pitch,
                duration: note.duration,
                type: note.type,
            },
            beat: currentBeat + totalBeatsBefore,
        };
    }).filter(item => item.note.pitch); // Only include notes with pitch (exclude rests)
});
---

<div
    class={`grid staff-host overflow-x-auto relative`}
    style="padding-inline: 49vw;"
>
    <div
        style={`grid-template-columns: 18em repeat(${totalMeasures}, 120px 120px 120px 120px);`}
        class={`staff-grid p-10 row-span-full grid ${stavesGrids[staves]}`}
    >
        <PartitureBeats
            beats={totalBeats}
            beatsPerMeasure={currentMeasureAttributes?.time.beats || 4}
            offsetStart={1}
        />
        {
            Array.from({ length: staves }).map((_, idx) => (
                <PartitureStaff
                    staffNumber={idx + 1}
                    clef={idx === 0 ? "treble" : "bass"}
                />
            ))
        }
        {
            mappedMeasures.map((measure) => {
                return <PartitureMeasure measure={measure} offsetStart={1} />;
            })
        }
    </div>
    <div class="playhead"></div>
</div>
<style is:global>
    .grid-host {
        font-size: clamp(8px, 2vmin, 16px);
    }

    .beat {
        transition:
            background-color 0.2s ease,
            box-shadow 0.2s ease,
            opacity 0.2s ease;
    }

    .beat.active {
        background-color: rgba(59, 130, 246, 0.5);
        box-shadow: 0 0 10px rgba(59, 130, 246, 0.7);
    }

    .beat.complete {
        background-color: rgba(59, 130, 246, 0);
        transition-duration: 0.5s;
    }

    .playhead {
        position: sticky;
        top: 0;
        bottom: 0;
        grid-column: 1 / -1;
        position: sticky;
        left: 0;
        grid-row: 1 / -1;
        width: 2px;
        background: rgba(59, 130, 246, 0.9);
        pointer-events: none;
        z-index: 50;
    }
</style>
<script is:inline define:vars={{ tempo, totalBeats, notesForAudio, divisions }}>
    // Store partiture data in global scope for audio integration
    window.__partitureData = window.__partitureData || {};
    window.__partitureData.tempo = tempo;
    window.__partitureData.totalBeats = totalBeats;
    window.__partitureData.notesForAudio = notesForAudio;
    window.__partitureData.divisions = divisions;
</script>
<script>
    import { PianoAudioPlayer } from "../../utils/audio-engine";
    
    const tempo = window.__partitureData?.tempo || 120;
    const totalBeats = window.__partitureData?.totalBeats || 0;
    const notesForAudio = window.__partitureData?.notesForAudio || [];
    const divisions = window.__partitureData?.divisions || 1;
    
    const DEFAULT_TEMPO = Number(tempo) || 120;
    const TOTAL_BEATS_HINT = Number(totalBeats) || 0;
    const PLAYHEAD_BAND_HALF = 12;
    const PLAY_START_DELAY_MS = 1000;
    const prefersReducedMotion = window.matchMedia(
        "(prefers-reduced-motion: reduce)",
    ).matches;
    
    // Audio player instance (shared across all hosts)
    const audioPlayer = new PianoAudioPlayer();
    let audioInitialized = false;

    const state = {
        tempo: DEFAULT_TEMPO,
        msPerBeat: (60 / DEFAULT_TEMPO) * 1000,
        hosts: [],
        playing: false,
        rafId: null,
        audioScheduled: false,
    };

    const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

    function averageSpacing(beats) {
        if (!beats || beats.length < 2) return 0;
        let total = 0;
        let samples = 0;
        const limit = Math.min(8, beats.length - 1);
        for (let i = 0; i < limit; i++) {
            const a = beats[i].getBoundingClientRect();
            const b = beats[i + 1].getBoundingClientRect();
            const delta = b.left - a.left;
            if (!Number.isFinite(delta) || delta === 0) continue;
            total += delta;
            samples++;
        }
        return samples ? total / samples : 0;
    }

    function createHost(hostEl) {
        const grid = hostEl.querySelector(".staff-grid");
        if (!grid) return null;

        const beats = Array.from(grid.querySelectorAll(".beat"));
        const notes = Array.from(grid.querySelectorAll(".note-visual"));

        const ctx = {
            host: hostEl,
            grid,
            beats,
            notes,
            totalBeats: beats.length || TOTAL_BEATS_HINT,
            spacing: 0,
            progress: 0,
            playheadX: 0,
            maxScroll: 0,
            initialScroll: 0,
            playing: false,
            playStartBeat: 0,
            playStartTime: 0,
            scrubbing: false,
            resumeAfterScrub: false,
            scrubStartX: 0,
            scrubStartBeat: 0,
            ignoreScroll: false,
            ignoreScrollRaf: null,
            observer: null,
            interval: null,
            playheadEl: hostEl.querySelector(".playhead") || null,
            initialised: false,
        };

        ctx.reduced =
            prefersReducedMotion ||
            !ctx.totalBeats ||
            beats.length === 0;

        ctx.spacing = averageSpacing(beats);
        if (!Number.isFinite(ctx.spacing) || ctx.spacing <= 0) {
            ctx.spacing = 0;
            ctx.reduced = true;
        }

        function setScroll(value) {
            const clamped = clamp(value, 0, ctx.maxScroll);
            if (Math.abs(ctx.host.scrollLeft - clamped) < 0.5) return;
            ctx.ignoreScroll = true;
            if (ctx.ignoreScrollRaf !== null) {
                window.cancelAnimationFrame(ctx.ignoreScrollRaf);
                ctx.ignoreScrollRaf = null;
            }
            ctx.host.scrollLeft = clamped;
            ctx.ignoreScrollRaf = window.requestAnimationFrame(() => {
                ctx.ignoreScroll = false;
                ctx.ignoreScrollRaf = null;
            });
        }

        function syncScroll() {
            const spacing = ctx.spacing > 0 ? ctx.spacing : 0;
            const target = spacing
                ? ctx.initialScroll + ctx.progress * spacing
                : ctx.initialScroll;
            setScroll(target);
        }

        function setBeat(beat, options = {}) {
            const { sync = true, source = "set" } = options;
            const clamped = clamp(beat, 0, ctx.totalBeats || 0);
            ctx.progress = clamped;

            if (sync) syncScroll();

            if (source !== "tick" && ctx.playing && !ctx.reduced) {
                ctx.playStartBeat = clamped;
                ctx.playStartTime = performance.now();
            }
        }

        function handleSeek(detail) {
            if (!detail) return;
            if (typeof detail.beat === "number") {
                setBeat(detail.beat);
            } else if (typeof detail.progress === "number") {
                setBeat(detail.progress * ctx.totalBeats);
            } else if (typeof detail.deltaBeat === "number") {
                setBeat(ctx.progress + detail.deltaBeat);
            }
        }

        function handleScroll() {
            if (ctx.ignoreScroll || ctx.spacing <= 0) return;
            const beat =
                (ctx.host.scrollLeft - ctx.initialScroll) / ctx.spacing;
            setBeat(beat, { sync: false, source: "scroll" });
        }

        function finishScrub(pointerId) {
            ctx.scrubbing = false;
            try {
                if (ctx.host.hasPointerCapture(pointerId)) {
                    ctx.host.releasePointerCapture(pointerId);
                }
            } catch (e) {}
            if (ctx.resumeAfterScrub) setPlaying(true);
        }

        function attachInputHandlers() {
            ctx.onPointerDown = (event) => {
                if (!event.isPrimary) return;
                ctx.scrubbing = true;
                ctx.resumeAfterScrub = state.playing;
                setPlaying(false);
                ctx.scrubStartX = event.clientX;
                ctx.scrubStartBeat = ctx.progress;
                try {
                    ctx.host.setPointerCapture(event.pointerId);
                } catch (e) {}
            };

            ctx.onPointerMove = (event) => {
                if (!ctx.scrubbing) return;
                const deltaPx = event.clientX - ctx.scrubStartX;
                const beatsDelta = ctx.spacing
                    ? deltaPx / ctx.spacing
                    : 0;
                setBeat(ctx.scrubStartBeat - beatsDelta);
            };

            ctx.onPointerUp = (event) => {
                if (ctx.scrubbing) finishScrub(event.pointerId);
            };

            ctx.onPointerCancel = (event) => {
                if (ctx.scrubbing) finishScrub(event.pointerId);
            };

            ctx.onWheel = (event) => {
                if (!event.shiftKey || ctx.spacing <= 0) return;
                event.preventDefault();
                setBeat(ctx.progress + event.deltaY / ctx.spacing);
            };

            ctx.onScroll = handleScroll;

            ctx.host.addEventListener("pointerdown", ctx.onPointerDown);
            ctx.host.addEventListener("pointermove", ctx.onPointerMove);
            ctx.host.addEventListener("pointerup", ctx.onPointerUp);
            ctx.host.addEventListener("pointercancel", ctx.onPointerCancel);
            ctx.host.addEventListener("wheel", ctx.onWheel, {
                passive: false,
            });
            ctx.host.addEventListener("scroll", ctx.onScroll, {
                passive: true,
            });
        }

        function refreshObserver() {
            if (ctx.observer) {
                try {
                    ctx.observer.disconnect();
                } catch (e) {}
                ctx.observer = null;
            }

            const hostWidth =
                ctx.host.clientWidth ||
                ctx.host.getBoundingClientRect().width ||
                0;
            if (!hostWidth) return;

            const bandStart = clamp(
                ctx.playheadX - PLAYHEAD_BAND_HALF,
                0,
                hostWidth,
            );
            const bandEnd = clamp(
                ctx.playheadX + PLAYHEAD_BAND_HALF,
                0,
                hostWidth,
            );
            const rootMargin = `0px -${Math.max(
                0,
                hostWidth - bandEnd,
            )}px 0px -${bandStart}px`;

            ctx.observer = new IntersectionObserver(
                (entries) => {
                    const viewportCenter =
                        (window.innerWidth ||
                            document.documentElement.clientWidth) / 2;
                    entries.forEach((entry) => {
                        const target = entry.target;
                        if (!target) return;
                        if (entry.isIntersecting) {
                            target.classList.add("active");
                            target.classList.remove("complete");
                        } else {
                            target.classList.remove("active");
                            const rect = entry.boundingClientRect;
                            if (rect && rect.right < viewportCenter) {
                                target.classList.add("complete");
                            } else {
                                target.classList.remove("complete");
                            }
                        }
                    });
                },
                { root: ctx.host, threshold: [0], rootMargin },
            );

            const observe = (el) => ctx.observer && ctx.observer.observe(el);
            ctx.beats.forEach(observe);
            ctx.notes.forEach(observe);
        }

        function remeasure() {
            const rect = ctx.host.getBoundingClientRect();
            const hostWidth = rect.width || ctx.host.offsetWidth || 0;
            const hostClientWidth = ctx.host.clientWidth || hostWidth;
            const viewportCenter =
                (window.innerWidth || document.documentElement.clientWidth) / 2;
            ctx.playheadX = Math.round(viewportCenter - rect.left);

            ctx.spacing = averageSpacing(ctx.beats);
            if (!Number.isFinite(ctx.spacing) || ctx.spacing <= 0) {
                ctx.spacing = 0;
                ctx.reduced = true;
            }

            ctx.maxScroll = Math.max(
                0,
                ctx.host.scrollWidth - hostClientWidth,
            );

            let desiredScroll = ctx.initialScroll;
            const firstBeat = ctx.beats[0];
            if (firstBeat) {
                const beatRect = firstBeat.getBoundingClientRect();
                desiredScroll =
                    ctx.host.scrollLeft +
                    (beatRect.left - (rect.left + ctx.playheadX));
            } else {
                desiredScroll = 0;
            }
            desiredScroll = clamp(desiredScroll, 0, ctx.maxScroll);

            if (!ctx.initialised) {
                ctx.initialScroll = 0;
                ctx.initialised = true;
            } else {
                ctx.initialScroll = desiredScroll;
            }

            syncScroll();
            refreshObserver();
        }

        function startInterval() {
            if (ctx.interval || ctx.totalBeats <= 0) return;
            let beat = ctx.progress;
            ctx.interval = window.setInterval(() => {
                beat = (beat + 1) % ctx.totalBeats;
                setBeat(beat, { source: "interval" });
            }, state.msPerBeat);
        }

        function stopInterval() {
            if (!ctx.interval) return;
            window.clearInterval(ctx.interval);
            ctx.interval = null;
        }

        function play() {
            if (ctx.playing) return;
            ctx.playing = true;
            if (ctx.reduced) {
                startInterval();
                return;
            }
            ctx.playStartBeat = ctx.progress;
            const delay = ctx.progress <= 0 ? PLAY_START_DELAY_MS : 0;
            ctx.playStartTime = performance.now() + delay;
        }

        function pause() {
            if (!ctx.playing) return;
            ctx.playing = false;
            if (ctx.reduced) {
                stopInterval();
            }
        }

        function onTempoChange() {
            if (ctx.reduced) {
                const wasRunning = ctx.playing;
                stopInterval();
                if (wasRunning) startInterval();
                return;
            }
            if (ctx.playing) {
                ctx.playStartBeat = ctx.progress;
                ctx.playStartTime = performance.now();
            }
        }

        function tick(now) {
            if (!ctx.playing || ctx.reduced || ctx.scrubbing) return;
            const msPerBeat = state.msPerBeat;
            if (!Number.isFinite(msPerBeat) || msPerBeat <= 0) return;
            if (!ctx.playStartTime) {
                ctx.playStartTime = now;
                ctx.playStartBeat = ctx.progress;
            }
            if (now < ctx.playStartTime) {
                // Hold the current beat during the pre-roll countdown.
                setBeat(ctx.playStartBeat, { source: "tick" });
                return;
            }
            const elapsed = now - ctx.playStartTime;
            const elapsedBeats = elapsed / msPerBeat;
            if (!Number.isFinite(elapsedBeats)) return;
            let beat = ctx.playStartBeat + elapsedBeats;
            if (ctx.totalBeats > 0) {
                beat %= ctx.totalBeats;
                if (beat < 0) beat += ctx.totalBeats;
            }
            setBeat(beat, { source: "tick" });
        }

        function destroy() {
            pause();
            stopInterval();
            if (ctx.observer) {
                try {
                    ctx.observer.disconnect();
                } catch (e) {}
                ctx.observer = null;
            }
            if (ctx.ignoreScrollRaf !== null) {
                window.cancelAnimationFrame(ctx.ignoreScrollRaf);
                ctx.ignoreScrollRaf = null;
            }
            ctx.host.removeEventListener("pointerdown", ctx.onPointerDown);
            ctx.host.removeEventListener("pointermove", ctx.onPointerMove);
            ctx.host.removeEventListener("pointerup", ctx.onPointerUp);
            ctx.host.removeEventListener("pointercancel", ctx.onPointerCancel);
            ctx.host.removeEventListener("wheel", ctx.onWheel);
            ctx.host.removeEventListener("scroll", ctx.onScroll);
        }

        ctx.setBeat = setBeat;
        ctx.play = play;
        ctx.pause = pause;
        ctx.tick = tick;
        ctx.onTempoChange = onTempoChange;
        ctx.handleSeek = handleSeek;
        ctx.remeasure = remeasure;
        ctx.destroy = destroy;
        ctx.syncScroll = syncScroll;

        attachInputHandlers();
        remeasure();

        return ctx;
    }

    function rebuildHosts() {
        state.hosts.forEach((host) => host.destroy());
        state.hosts = [];

        const hosts = Array.from(document.querySelectorAll(".staff-host"));
        hosts.forEach((element) => {
            const host = createHost(element);
            if (!host) return;
            state.hosts.push(host);
        });

        state.hosts.forEach((host) =>
            state.playing ? host.play() : host.pause(),
        );

        ensureTick();
    }

    function ensureTick() {
        if (state.rafId !== null) return;
        const step = (now) => {
            state.hosts.forEach((host) => host.tick(now));
            state.rafId = window.requestAnimationFrame(step);
        };
        state.rafId = window.requestAnimationFrame(step);
    }

    /**
     * Initialize audio on first user interaction
     */
    async function ensureAudioInitialized() {
        if (audioInitialized) return true;
        
        try {
            await audioPlayer.initialize();
            audioInitialized = true;
            return true;
        } catch (error) {
            console.error('Failed to initialize audio:', error);
            return false;
        }
    }

    /**
     * Schedule audio playback from a specific beat
     */
    function scheduleAudio(fromBeat = 0) {
        if (!audioInitialized || !notesForAudio) return;
        
        // Stop any currently playing audio
        audioPlayer.stopAll();
        
        // Schedule notes from the current beat
        audioPlayer.scheduleNotes(
            notesForAudio,
            state.tempo,
            divisions,
            fromBeat
        );
        
        state.audioScheduled = true;
    }

    /**
     * Stop all audio playback
     */
    function stopAudio() {
        if (!audioInitialized) return;
        audioPlayer.stopAll();
        state.audioScheduled = false;
    }

    async function setPlaying(shouldPlay) {
        const play = !!shouldPlay;
        if (state.playing === play) {
            state.hosts.forEach((host) =>
                play ? host.play() : host.pause(),
            );
            return;
        }
        state.playing = play;
        document.body.classList.toggle("playing", play);
        
        if (play) {
            // Initialize audio on first play
            const initialized = await ensureAudioInitialized();
            
            if (initialized && state.hosts.length > 0) {
                // Get current beat from first host
                const currentBeat = Math.floor(state.hosts[0]?.progress || 0);
                scheduleAudio(currentBeat);
            }
        } else {
            // Stop audio when pausing
            stopAudio();
        }
        
        state.hosts.forEach((host) =>
            play ? host.play() : host.pause(),
        );
    }

    function handleTempoChange(newTempo) {
        const tempoValue = Number(newTempo);
        if (!Number.isFinite(tempoValue) || tempoValue <= 0) return;
        if (tempoValue === state.tempo) return;
        state.tempo = tempoValue;
        state.msPerBeat = (60 / tempoValue) * 1000;
        state.hosts.forEach((host) => host.onTempoChange());
        
        // Reschedule audio with new tempo if playing
        if (state.playing && state.hosts.length > 0) {
            const currentBeat = Math.floor(state.hosts[0]?.progress || 0);
            scheduleAudio(currentBeat);
        }
    }

    function handleSeek(detail) {
        state.hosts.forEach((host) => host.handleSeek(detail));
        
        // Reschedule audio from new position if playing
        if (state.playing && state.hosts.length > 0) {
            const currentBeat = Math.floor(state.hosts[0]?.progress || 0);
            scheduleAudio(currentBeat);
        }
    }

    let resizeTimer = null;
    window.addEventListener("resize", () => {
        window.clearTimeout(resizeTimer);
        resizeTimer = window.setTimeout(() => {
            state.hosts.forEach((host) => host.remeasure());
        }, 120);
    });

    document.addEventListener("visibilitychange", () => {
        if (document.hidden) setPlaying(false);
    });

    document.addEventListener("piano:play-toggle", (event) => {
        setPlaying(!!event.detail);
    });

    document.addEventListener("piano:tempo-change", (event) => {
        handleTempoChange(event.detail);
    });

    document.addEventListener("piano:seek", (event) => {
        handleSeek(event.detail);
    });

    rebuildHosts();

    // Cleanup audio on page unload
    window.addEventListener('beforeunload', () => {
        audioPlayer.dispose();
    });

    window.__piano_staff = {
        rebuild: rebuildHosts,
        play: () => setPlaying(true),
        pause: () => setPlaying(false),
        setTempo: handleTempoChange,
        seek: handleSeek,
        isPlaying: () => state.playing,
        audioPlayer: audioPlayer,
        debug: () => {
            console.group("piano_staff");
            console.log("tempo", state.tempo);
            console.log("msPerBeat", state.msPerBeat);
            console.log("audioInitialized", audioInitialized);
            console.log("audioScheduled", state.audioScheduled);
            state.hosts.forEach((host, index) => {
                console.group(`host[${index}]`);
                console.log("progress", host.progress);
                console.log("totalBeats", host.totalBeats);
                console.log("spacing", host.spacing);
                console.log("scrollLeft", host.host.scrollLeft);
                console.log("reduced", host.reduced);
                console.groupEnd();
            });
            console.groupEnd();
        },
    };
</script>

