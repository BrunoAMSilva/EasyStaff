---
import type { Part, Note, Measure } from "../../content.config";
import type { TieInfo } from "../../types/tie";
import PartitureBeats from "./PartitureBeats.astro";
import PartitureMeasure from "./PartitureMeasure.astro";
import PartitureStaff from "./PartitureStaff.astro";
import PartitureSlursTies from "./PartitureSlursTies.astro";
import { prepareNotesForAudio } from "../../utils/audio-helpers";
import { extractTempo } from "../../utils/tempo";

interface Props {
    partiturePart: Part;
}

const { partiturePart } = Astro.props;
const firstMeasure = partiturePart.measures[0];
const staves = firstMeasure.attributes?.staves || 1;

// Calculate tie information for all notes
// This will help us extend first note duration and hide continuation notes
const tieInfoMap = new Map<string, TieInfo>(); // key: `measureIndex-noteIndex`

// Track active ties by pitch (staff-step-octave) to calculate total durations
const activeTieStarts = new Map<string, { key: string; duration: number }>();

partiturePart.measures.forEach((measure, measureIndex) => {
    measure.notes.forEach((note, noteIndex) => {
        if (!note.pitch) return;
        
        const key = `${measureIndex}-${noteIndex}`;
        const staff = note.staff || 1;
        const pitch = `${staff}-${note.pitch.step}${note.pitch.octave}`;
        
        const hasTieStart = note.tie?.type === 'start' || note.notations?.tied?.type === 'start';
        const hasTieStop = note.tie?.type === 'stop' || note.notations?.tied?.type === 'stop';
        
        if (hasTieStart && !hasTieStop) {
            // Pure start of a tie
            activeTieStarts.set(pitch, { key, duration: note.duration || 1 });
            tieInfoMap.set(key, {
                isStart: true,
                isMiddle: false,
                isEnd: false,
                totalDuration: note.duration || 1
            });
        } else if (hasTieStop) {
            const tieStart = activeTieStarts.get(pitch);
            if (tieStart) {
                tieStart.duration += (note.duration || 1);
                
                // Update the start note with accumulated duration
                const startInfo = tieInfoMap.get(tieStart.key);
                if (startInfo) {
                    startInfo.totalDuration = tieStart.duration;
                }
                
                // Mark this note as middle or end
                const isEnd = !hasTieStart;
                tieInfoMap.set(key, {
                    isStart: false,
                    isMiddle: !isEnd,
                    isEnd: isEnd,
                    totalDuration: 0
                });
                
                if (isEnd) {
                    activeTieStarts.delete(pitch);
                }
            }
        }
    });
});

// Make tie info available to measures via a global
// (Astro doesn't have React-style context, so we use this approach)
(globalThis as any).__tieInfoMap = tieInfoMap;
const stavesGrids: Record<number, string> = {
    1: "grid-rows-13",
    2: "grid-rows-26",
    3: "grid-rows-39",
};
let currentMeasureAttributes = firstMeasure.attributes;
let currentMeasureDirections = firstMeasure.directions;
const mappedMeasures = partiturePart.measures.map((measure) => {
    measure.attributes = measure.attributes
        ? { ...currentMeasureAttributes, ...measure.attributes }
        : currentMeasureAttributes;
    measure.directions = measure.directions
        ? measure.directions
        : currentMeasureDirections;
    currentMeasureAttributes = measure.attributes;
    currentMeasureDirections = measure.directions;
    return measure;
});

const totalMeasures = mappedMeasures.length;
const totalBeats = currentMeasureAttributes?.time.beats
    ? mappedMeasures.reduce((sum, measure) => {
          return sum + (measure.attributes?.time.beats || 0);
      }, 0)
    : mappedMeasures.length;
const tempo = extractTempo(currentMeasureDirections);
const divisions = currentMeasureAttributes?.divisions || 1;
// Prepare note data for audio playback using utility function
const notesForAudio = prepareNotesForAudio(partiturePart);
---

<div
    class={`grid staff-host overflow-x-auto relative`}
    
>
    <div
        style={`grid-template-columns: 18em repeat(${totalMeasures}, 120px 120px 120px 120px);`}
        class={`staff-grid p-10 row-span-full grid ${stavesGrids[staves]}`}
    >
        <PartitureBeats
            tempo={tempo}
            beats={totalBeats}
            beatsPerMeasure={currentMeasureAttributes?.time.beats || 4}
            offsetStart={1}
        />
        {
            Array.from({ length: staves }).map((_, idx) => (
                <PartitureStaff
                    staffNumber={idx + 1}
                    clef={idx === 0 ? "treble" : "bass"}
                />
            ))
        }
        {
            mappedMeasures.map((measure, index) => {
                return <PartitureMeasure measure={measure} offsetStart={1} measureIndex={index} />;
            })
        }
        <PartitureSlursTies partiturePart={partiturePart} />
    </div>
    <div class="playhead"></div>
</div>
<style is:global>

    .staff-grid {
        margin-inline-start: calc(50vw - (var(--spacing) * 16) - 16em);
        margin-inline-end: 48vw;
        font-size: clamp(0.75rem, 2vmin, 2rem);
    }

    .playhead {
        position: sticky;
        top: 0;
        bottom: 0;
        grid-column: 1 / -1;
        position: sticky;
        left: 50vw;
        grid-row: 1 / -1;
        width: 2px;
        background: rgba(59, 130, 246, 0.9);
        pointer-events: none;
        z-index: 50;
    }
</style>
<script is:inline define:vars={{ tempo, totalBeats, notesForAudio, divisions }}>
    // Store partiture data in window scope for audio integration
    // Use a unique key per component to avoid conflicts with multiple partitures
    window.__partitureData = window.__partitureData || {};
    window.__partitureData.tempo = tempo;
    window.__partitureData.totalBeats = totalBeats;
    window.__partitureData.notesForAudio = notesForAudio;
    window.__partitureData.divisions = divisions;
</script>
<script>
    import { PartiturePlayer } from "../../utils/partiture-player";
    
    const tempo = window.__partitureData?.tempo || 120;
    const totalBeats = window.__partitureData?.totalBeats || 0;
    const notesForAudio = window.__partitureData?.notesForAudio || [];
    const divisions = window.__partitureData?.divisions || 1;
    
    const player = new PartiturePlayer({
        defaultTempo: Number(tempo) || 120,
        totalBeatsHint: Number(totalBeats) || 0,
    });
    
    player.setAudioData(notesForAudio, divisions);
    player.setupEventListeners();
    player.rebuildHosts();
    
</script>

