---
/**
 * PartitureSlursTies Component
 * 
 * Renders slurs as thick gradient bars connecting notes.
 * For ties, this component tracks which notes should be hidden and calculates extended durations.
 */
import type { Part, Note } from "../../content.config";
import { getNoteColorByStep } from "../../utils/note-colors";

interface Props {
    partiturePart: Part;
}

const { partiturePart } = Astro.props;

interface NotePosition {
    note: Note;
    beat: number;
    measureNumber: number;
    staff: number;
    noteIndex: number;
}

// Build a complete list of note positions with their beat positions
const notePositions: NotePosition[] = [];
const firstMeasure = partiturePart.measures[0];
const staves = firstMeasure.attributes?.staves || 1;
const beatsPerMeasure = firstMeasure.attributes?.time.beats || 4;

partiturePart.measures.forEach((measure, measureIndex) => {
    const measureNumber = parseInt(measure.number || '1');
    const totalBeatsBefore = (measureNumber - 1) * beatsPerMeasure + 1;
    
    const currentBeats = new Map<number, number>(
        new Array(staves).fill(0).map((_, idx) => [idx + 1, 0])
    );
    const lastNotes = new Map<number, Note>();
    
    measure.notes.forEach((note, noteIndex) => {
        const staff = note.staff || 1;
        const beat = currentBeats.get(staff) || 0;
        const lastNote = lastNotes.get(staff);
        lastNotes.set(staff, note);
        
        let currentBeat: number;
        if (!lastNote || note.isChord) {
            currentBeat = beat === 0 ? 1 : beat;
            currentBeats.set(staff, currentBeat);
        } else {
            currentBeat = beat === 0 ? 1 : beat + (lastNote.duration || 1);
            currentBeats.set(staff, currentBeat);
        }
        
        notePositions.push({
            note,
            beat: currentBeat + totalBeatsBefore,
            measureNumber,
            staff,
            noteIndex: notePositions.length
        });
    });
});

// Track slurs only - ties will be handled differently
interface Slur {
    startPos: NotePosition;
    endPos?: NotePosition;
    number?: number;
}

const activeSlurs = new Map<number, Slur>();
const completedSlurs: Slur[] = [];

// Process notes to match slur starts with stops
notePositions.forEach((pos) => {
    const note = pos.note;
    
    // Handle slurs
    if (note.notations?.slur) {
        const slur = note.notations.slur;
        const slurNumber = slur.number || 1;
        
        if (slur.type === 'start') {
            activeSlurs.set(slurNumber, {
                startPos: pos,
                number: slurNumber
            });
        } else if (slur.type === 'stop') {
            const activeSlur = activeSlurs.get(slurNumber);
            if (activeSlur) {
                activeSlur.endPos = pos;
                completedSlurs.push(activeSlur);
                activeSlurs.delete(slurNumber);
            }
        }
    }
});

// Helper to get row position based on staff for slur bars
function getRowForStaff(staff: number, staves: number): number {
    // Position bars above the note rows to avoid overlap
    // Each staff has 13 rows, place slur bars 2 rows above the middle
    if (staves === 1) {
        return 5; // Above the middle row for single staff
    } else if (staves === 2) {
        return staff === 1 ? 5 : 18; // Above the middle row for each staff
    } else {
        return staff === 1 ? 5 : (staff === 2 ? 18 : 31);
    }
}

// Get color for note step
function getColorStyle(step: string): string {
    // Extract just the RGB values from Tailwind classes
    const colors: { [key: string]: string } = {
        "C": "126, 34, 206",     // purple-700
        "D": "234, 88, 12",      // orange-600
        "E": "77, 124, 15",      // lime-700
        "F": "159, 18, 57",      // rose-800
        "G": "55, 48, 163",      // indigo-800
        "A": "236, 72, 153",     // pink-500
        "B": "15, 118, 110",     // teal-700
    };
    return colors[step] || "107, 114, 128"; // gray-500 default
}
---

{/* Render slurs as thick gradient bars */}
{completedSlurs.map((slur, index) => {
    if (!slur.endPos) return null;
    
    const startBeat = slur.startPos.beat;
    const endBeat = slur.endPos.beat;
    const endNoteDuration = slur.endPos.note.duration || 1;
    const staff = slur.startPos.staff;
    const row = getRowForStaff(staff, staves);
    
    // Calculate span (how many beats the bar covers)
    // Include the duration of the end note so the bar extends to the end of the last note
    const span = (endBeat - startBeat) + endNoteDuration;
    
    // Get colors from both notes
    const startColor = getColorStyle(slur.startPos.note.pitch?.step || "C");
    const endColor = getColorStyle(slur.endPos.note.pitch?.step || "C");
    
    return (
        <div
            class="slur-bar"
            style={`
                grid-column: ${startBeat} / span ${span};
                grid-row: ${row};
                background: linear-gradient(to right, rgb(${startColor}), rgb(${endColor}));
            `}
            data-start={startBeat}
            data-end={endBeat}
        />
    );
})}

<style>
    .slur-bar {
        position: relative;
        pointer-events: none;
        z-index: 1;
        height: 60%;
        border-radius: 0.5rem;
        opacity: 0.9;
        margin: 0.5rem;
        align-self: center;
    }
</style>
